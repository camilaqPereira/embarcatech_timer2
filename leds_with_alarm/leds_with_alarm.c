#include <stdio.h>
#include "pico/stdlib.h"

/* Constants declaration */
const uint32_t led_sequence_delay_ms = 3000; //Delay between led sequence steps in ms
const int64_t led_sequence_delay_us = 3000000; ////Delay between led sequence steps in us

const uint32_t debounce_delay_ms = 50;      //Debouce delay in ms

const uint GPIO_RED_LED = 13;   // Red led pin
const uint GPIO_BLUE_LED = 12;  // Blue led pin
const uint GPIO_GREEN_LED = 11; // Green led pin
const uint GPIO_BUTTON_A = 5;   // Button A pin
const uint led_mask = 0b11100000000000; //Mask for RGB LED
const uint button_mask = 0b00000100000; //Mask for button A



/* Function prototypes */
void button_press_handler(uint gpio, uint32_t events);
int64_t led_sequence_callback(alarm_id_t id, void* user_data);
int64_t debounce_callback(alarm_id_t id, void* user_data);


/* Global variables  */

static volatile alarm_id_t alarm_id = 0;    //Id of the debounce alarm

static volatile bool last_state = true;     //Last state of the button

static volatile bool sequence_on = false; // Led sequence status

static volatile uint leds_activated = 7;    //Leds to activate
                                            // 111 -> all leds on
                                            // 110 -> blue and green on
                                            // 100 -> green on
                                            //000 -> all leds off

int main()
{
    /* Pin initialization*/
    stdio_init_all();

    gpio_init_mask(led_mask | button_mask);
    gpio_set_dir_masked(led_mask | button_mask, led_mask);
    gpio_pull_up(GPIO_BUTTON_A);
    
    /* IRQ configuration*/
    gpio_set_irq_enabled_with_callback(GPIO_BUTTON_A, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &button_press_handler);

    while (true) {
        sleep_ms(10000);
    }
}

/*
*   @brief Callback for IRQ generated by pin 5 (pushbutton)
*/


void button_press_handler(uint gpio, uint32_t events){

    if(alarm_id){ //Reset debounce alarm
        cancel_alarm(alarm_id); // Cancel previous alarm
        alarm_id = 0;
    }
    
    //New debouce alarm
    alarm_id = add_alarm_in_ms(debounce_delay_ms, &debounce_callback, NULL, false);


}

/*
*   @brief Callback for led sequence alarm
*/
int64_t led_sequence_callback(alarm_id_t id, void* user_data) {
    // Activate next step
    gpio_put_masked(led_mask, leds_activated << 11);


    if (leds_activated){ //update sequence step
        leds_activated = leds_activated >> 1; //update sequence
        return led_sequence_delay_us;         // set alarm to new shot

    }else{ //if all leds are of

        //Reconfigure sequence
        leds_activated = 7;
        sequence_on = false;
        return 0; //stop alarm
    }
}


/*
*   @brief  Callback for debouce alarm
*/
int64_t debounce_callback(alarm_id_t id, void* user_data){
    //Current state of the button
    bool current_state = gpio_get(GPIO_BUTTON_A);

    if (last_state != current_state){ //Pushbutton stable
        last_state = current_state;

        if (!current_state && !sequence_on){ //Button pressed and sequence not active

            sequence_on = true; // flag sequence as active
        
            // Activate first step
            gpio_put_masked(led_mask, leds_activated << 11); 
            leds_activated = leds_activated >> 1;

            //Configure alarm for next step
            add_alarm_in_ms(led_sequence_delay_ms, led_sequence_callback, NULL, false);
        }
        
    }

    /* Reset debounce alarm*/
    alarm_id = 0;
    
    return 0; //stop alarm
    
}


